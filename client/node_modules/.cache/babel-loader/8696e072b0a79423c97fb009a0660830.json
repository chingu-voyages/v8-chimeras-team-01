{"ast":null,"code":"parcelRequire = function (e, r, n, t) {\n  var i = \"function\" == typeof parcelRequire && parcelRequire,\n      o = \"function\" == typeof require && require;\n\n  function u(n, t) {\n    if (!r[n]) {\n      if (!e[n]) {\n        var f = \"function\" == typeof parcelRequire && parcelRequire;\n        if (!t && f) return f(n, !0);\n        if (i) return i(n, !0);\n        if (o && \"string\" == typeof n) return o(n);\n        var c = new Error(\"Cannot find module '\" + n + \"'\");\n        throw c.code = \"MODULE_NOT_FOUND\", c;\n      }\n\n      p.resolve = function (r) {\n        return e[n][1][r] || r;\n      }, p.cache = {};\n      var l = r[n] = new u.Module(n);\n      e[n][0].call(l.exports, p, l, l.exports, this);\n    }\n\n    return r[n].exports;\n\n    function p(e) {\n      return u(p.resolve(e));\n    }\n  }\n\n  u.isParcelRequire = !0, u.Module = function (e) {\n    this.id = e, this.bundle = u, this.exports = {};\n  }, u.modules = e, u.cache = r, u.parent = i, u.register = function (r, n) {\n    e[r] = [function (e, r) {\n      r.exports = n;\n    }, {}];\n  };\n\n  for (var f = 0; f < n.length; f++) {\n    u(n[f]);\n  }\n\n  if (n.length) {\n    var c = u(n[n.length - 1]);\n    \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = c : \"function\" == typeof define && define.amd ? define(function () {\n      return c;\n    }) : t && (this[t] = c);\n  }\n\n  return u;\n}({\n  \"vHo1\": [function (require, module, exports) {\n    var e = {};\n    e.useBlobBuilder = function () {\n      try {\n        return new Blob([]), !1;\n      } catch (e) {\n        return !0;\n      }\n    }(), e.useArrayBufferView = !e.useBlobBuilder && function () {\n      try {\n        return 0 === new Blob([new Uint8Array([])]).size;\n      } catch (e) {\n        return !0;\n      }\n    }(), module.exports.binaryFeatures = e;\n    var r = module.exports.BlobBuilder;\n\n    function t() {\n      this._pieces = [], this._parts = [];\n    }\n\n    \"undefined\" != typeof window && (r = module.exports.BlobBuilder = window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder || window.BlobBuilder), t.prototype.append = function (e) {\n      \"number\" == typeof e ? this._pieces.push(e) : (this.flush(), this._parts.push(e));\n    }, t.prototype.flush = function () {\n      if (this._pieces.length > 0) {\n        var r = new Uint8Array(this._pieces);\n        e.useArrayBufferView || (r = r.buffer), this._parts.push(r), this._pieces = [];\n      }\n    }, t.prototype.getBuffer = function () {\n      if (this.flush(), e.useBlobBuilder) {\n        for (var t = new r(), i = 0, u = this._parts.length; i < u; i++) {\n          t.append(this._parts[i]);\n        }\n\n        return t.getBlob();\n      }\n\n      return new Blob(this._parts);\n    }, module.exports.BufferBuilder = t;\n  }, {}],\n  \"lHOc\": [function (require, module, exports) {\n    var t = require(\"./bufferbuilder\").BufferBuilder,\n        e = require(\"./bufferbuilder\").binaryFeatures,\n        i = {\n      unpack: function unpack(t) {\n        return new r(t).unpack();\n      },\n      pack: function pack(t) {\n        var e = new n();\n        return e.pack(t), e.getBuffer();\n      }\n    };\n\n    function r(t) {\n      this.index = 0, this.dataBuffer = t, this.dataView = new Uint8Array(this.dataBuffer), this.length = this.dataBuffer.byteLength;\n    }\n\n    function n() {\n      this.bufferBuilder = new t();\n    }\n\n    function u(t) {\n      var e = t.charCodeAt(0);\n      return e <= 2047 ? \"00\" : e <= 65535 ? \"000\" : e <= 2097151 ? \"0000\" : e <= 67108863 ? \"00000\" : \"000000\";\n    }\n\n    function a(t) {\n      return t.length > 600 ? new Blob([t]).size : t.replace(/[^\\u0000-\\u007F]/g, u).length;\n    }\n\n    module.exports = i, r.prototype.unpack = function () {\n      var t,\n          e = this.unpack_uint8();\n      if (e < 128) return e;\n      if ((224 ^ e) < 32) return (224 ^ e) - 32;\n      if ((t = 160 ^ e) <= 15) return this.unpack_raw(t);\n      if ((t = 176 ^ e) <= 15) return this.unpack_string(t);\n      if ((t = 144 ^ e) <= 15) return this.unpack_array(t);\n      if ((t = 128 ^ e) <= 15) return this.unpack_map(t);\n\n      switch (e) {\n        case 192:\n          return null;\n\n        case 193:\n          return;\n\n        case 194:\n          return !1;\n\n        case 195:\n          return !0;\n\n        case 202:\n          return this.unpack_float();\n\n        case 203:\n          return this.unpack_double();\n\n        case 204:\n          return this.unpack_uint8();\n\n        case 205:\n          return this.unpack_uint16();\n\n        case 206:\n          return this.unpack_uint32();\n\n        case 207:\n          return this.unpack_uint64();\n\n        case 208:\n          return this.unpack_int8();\n\n        case 209:\n          return this.unpack_int16();\n\n        case 210:\n          return this.unpack_int32();\n\n        case 211:\n          return this.unpack_int64();\n\n        case 212:\n        case 213:\n        case 214:\n        case 215:\n          return;\n\n        case 216:\n          return t = this.unpack_uint16(), this.unpack_string(t);\n\n        case 217:\n          return t = this.unpack_uint32(), this.unpack_string(t);\n\n        case 218:\n          return t = this.unpack_uint16(), this.unpack_raw(t);\n\n        case 219:\n          return t = this.unpack_uint32(), this.unpack_raw(t);\n\n        case 220:\n          return t = this.unpack_uint16(), this.unpack_array(t);\n\n        case 221:\n          return t = this.unpack_uint32(), this.unpack_array(t);\n\n        case 222:\n          return t = this.unpack_uint16(), this.unpack_map(t);\n\n        case 223:\n          return t = this.unpack_uint32(), this.unpack_map(t);\n      }\n    }, r.prototype.unpack_uint8 = function () {\n      var t = 255 & this.dataView[this.index];\n      return this.index++, t;\n    }, r.prototype.unpack_uint16 = function () {\n      var t = this.read(2),\n          e = 256 * (255 & t[0]) + (255 & t[1]);\n      return this.index += 2, e;\n    }, r.prototype.unpack_uint32 = function () {\n      var t = this.read(4),\n          e = 256 * (256 * (256 * t[0] + t[1]) + t[2]) + t[3];\n      return this.index += 4, e;\n    }, r.prototype.unpack_uint64 = function () {\n      var t = this.read(8),\n          e = 256 * (256 * (256 * (256 * (256 * (256 * (256 * t[0] + t[1]) + t[2]) + t[3]) + t[4]) + t[5]) + t[6]) + t[7];\n      return this.index += 8, e;\n    }, r.prototype.unpack_int8 = function () {\n      var t = this.unpack_uint8();\n      return t < 128 ? t : t - 256;\n    }, r.prototype.unpack_int16 = function () {\n      var t = this.unpack_uint16();\n      return t < 32768 ? t : t - 65536;\n    }, r.prototype.unpack_int32 = function () {\n      var t = this.unpack_uint32();\n      return t < Math.pow(2, 31) ? t : t - Math.pow(2, 32);\n    }, r.prototype.unpack_int64 = function () {\n      var t = this.unpack_uint64();\n      return t < Math.pow(2, 63) ? t : t - Math.pow(2, 64);\n    }, r.prototype.unpack_raw = function (t) {\n      if (this.length < this.index + t) throw new Error(\"BinaryPackFailure: index is out of range \" + this.index + \" \" + t + \" \" + this.length);\n      var e = this.dataBuffer.slice(this.index, this.index + t);\n      return this.index += t, e;\n    }, r.prototype.unpack_string = function (t) {\n      for (var e, i, r = this.read(t), n = 0, u = \"\"; n < t;) {\n        (e = r[n]) < 128 ? (u += String.fromCharCode(e), n++) : (192 ^ e) < 32 ? (i = (192 ^ e) << 6 | 63 & r[n + 1], u += String.fromCharCode(i), n += 2) : (i = (15 & e) << 12 | (63 & r[n + 1]) << 6 | 63 & r[n + 2], u += String.fromCharCode(i), n += 3);\n      }\n\n      return this.index += t, u;\n    }, r.prototype.unpack_array = function (t) {\n      for (var e = new Array(t), i = 0; i < t; i++) {\n        e[i] = this.unpack();\n      }\n\n      return e;\n    }, r.prototype.unpack_map = function (t) {\n      for (var e = {}, i = 0; i < t; i++) {\n        var r = this.unpack(),\n            n = this.unpack();\n        e[r] = n;\n      }\n\n      return e;\n    }, r.prototype.unpack_float = function () {\n      var t = this.unpack_uint32(),\n          e = (t >> 23 & 255) - 127;\n      return (0 == t >> 31 ? 1 : -1) * (8388607 & t | 8388608) * Math.pow(2, e - 23);\n    }, r.prototype.unpack_double = function () {\n      var t = this.unpack_uint32(),\n          e = this.unpack_uint32(),\n          i = (t >> 20 & 2047) - 1023;\n      return (0 == t >> 31 ? 1 : -1) * ((1048575 & t | 1048576) * Math.pow(2, i - 20) + e * Math.pow(2, i - 52));\n    }, r.prototype.read = function (t) {\n      var e = this.index;\n      if (e + t <= this.length) return this.dataView.subarray(e, e + t);\n      throw new Error(\"BinaryPackFailure: read index out of range\");\n    }, n.prototype.getBuffer = function () {\n      return this.bufferBuilder.getBuffer();\n    }, n.prototype.pack = function (t) {\n      var i = typeof t;\n      if (\"string\" == i) this.pack_string(t);else if (\"number\" == i) Math.floor(t) === t ? this.pack_integer(t) : this.pack_double(t);else if (\"boolean\" == i) !0 === t ? this.bufferBuilder.append(195) : !1 === t && this.bufferBuilder.append(194);else if (\"undefined\" == i) this.bufferBuilder.append(192);else {\n        if (\"object\" != i) throw new Error('Type \"' + i + '\" not yet supported');\n        if (null === t) this.bufferBuilder.append(192);else {\n          var r = t.constructor;\n          if (r == Array) this.pack_array(t);else if (r == Blob || r == File) this.pack_bin(t);else if (r == ArrayBuffer) e.useArrayBufferView ? this.pack_bin(new Uint8Array(t)) : this.pack_bin(t);else if (\"BYTES_PER_ELEMENT\" in t) e.useArrayBufferView ? this.pack_bin(new Uint8Array(t.buffer)) : this.pack_bin(t.buffer);else if (r == Object) this.pack_object(t);else if (r == Date) this.pack_string(t.toString());else {\n            if (\"function\" != typeof t.toBinaryPack) throw new Error('Type \"' + r.toString() + '\" not yet supported');\n            this.bufferBuilder.append(t.toBinaryPack());\n          }\n        }\n      }\n      this.bufferBuilder.flush();\n    }, n.prototype.pack_bin = function (t) {\n      var e = t.length || t.byteLength || t.size;\n      if (e <= 15) this.pack_uint8(160 + e);else if (e <= 65535) this.bufferBuilder.append(218), this.pack_uint16(e);else {\n        if (!(e <= 4294967295)) throw new Error(\"Invalid length\");\n        this.bufferBuilder.append(219), this.pack_uint32(e);\n      }\n      this.bufferBuilder.append(t);\n    }, n.prototype.pack_string = function (t) {\n      var e = a(t);\n      if (e <= 15) this.pack_uint8(176 + e);else if (e <= 65535) this.bufferBuilder.append(216), this.pack_uint16(e);else {\n        if (!(e <= 4294967295)) throw new Error(\"Invalid length\");\n        this.bufferBuilder.append(217), this.pack_uint32(e);\n      }\n      this.bufferBuilder.append(t);\n    }, n.prototype.pack_array = function (t) {\n      var e = t.length;\n      if (e <= 15) this.pack_uint8(144 + e);else if (e <= 65535) this.bufferBuilder.append(220), this.pack_uint16(e);else {\n        if (!(e <= 4294967295)) throw new Error(\"Invalid length\");\n        this.bufferBuilder.append(221), this.pack_uint32(e);\n      }\n\n      for (var i = 0; i < e; i++) {\n        this.pack(t[i]);\n      }\n    }, n.prototype.pack_integer = function (t) {\n      if (-32 <= t && t <= 127) this.bufferBuilder.append(255 & t);else if (0 <= t && t <= 255) this.bufferBuilder.append(204), this.pack_uint8(t);else if (-128 <= t && t <= 127) this.bufferBuilder.append(208), this.pack_int8(t);else if (0 <= t && t <= 65535) this.bufferBuilder.append(205), this.pack_uint16(t);else if (-32768 <= t && t <= 32767) this.bufferBuilder.append(209), this.pack_int16(t);else if (0 <= t && t <= 4294967295) this.bufferBuilder.append(206), this.pack_uint32(t);else if (-2147483648 <= t && t <= 2147483647) this.bufferBuilder.append(210), this.pack_int32(t);else if (-0x8000000000000000 <= t && t <= 0x8000000000000000) this.bufferBuilder.append(211), this.pack_int64(t);else {\n        if (!(0 <= t && t <= 0x10000000000000000)) throw new Error(\"Invalid integer\");\n        this.bufferBuilder.append(207), this.pack_uint64(t);\n      }\n    }, n.prototype.pack_double = function (t) {\n      var e = 0;\n      t < 0 && (e = 1, t = -t);\n      var i = Math.floor(Math.log(t) / Math.LN2),\n          r = t / Math.pow(2, i) - 1,\n          n = Math.floor(r * Math.pow(2, 52)),\n          u = Math.pow(2, 32),\n          a = e << 31 | i + 1023 << 20 | n / u & 1048575,\n          p = n % u;\n      this.bufferBuilder.append(203), this.pack_int32(a), this.pack_int32(p);\n    }, n.prototype.pack_object = function (t) {\n      var e = Object.keys(t).length;\n      if (e <= 15) this.pack_uint8(128 + e);else if (e <= 65535) this.bufferBuilder.append(222), this.pack_uint16(e);else {\n        if (!(e <= 4294967295)) throw new Error(\"Invalid length\");\n        this.bufferBuilder.append(223), this.pack_uint32(e);\n      }\n\n      for (var i in t) {\n        t.hasOwnProperty(i) && (this.pack(i), this.pack(t[i]));\n      }\n    }, n.prototype.pack_uint8 = function (t) {\n      this.bufferBuilder.append(t);\n    }, n.prototype.pack_uint16 = function (t) {\n      this.bufferBuilder.append(t >> 8), this.bufferBuilder.append(255 & t);\n    }, n.prototype.pack_uint32 = function (t) {\n      var e = 4294967295 & t;\n      this.bufferBuilder.append((4278190080 & e) >>> 24), this.bufferBuilder.append((16711680 & e) >>> 16), this.bufferBuilder.append((65280 & e) >>> 8), this.bufferBuilder.append(255 & e);\n    }, n.prototype.pack_uint64 = function (t) {\n      var e = t / Math.pow(2, 32),\n          i = t % Math.pow(2, 32);\n      this.bufferBuilder.append((4278190080 & e) >>> 24), this.bufferBuilder.append((16711680 & e) >>> 16), this.bufferBuilder.append((65280 & e) >>> 8), this.bufferBuilder.append(255 & e), this.bufferBuilder.append((4278190080 & i) >>> 24), this.bufferBuilder.append((16711680 & i) >>> 16), this.bufferBuilder.append((65280 & i) >>> 8), this.bufferBuilder.append(255 & i);\n    }, n.prototype.pack_int8 = function (t) {\n      this.bufferBuilder.append(255 & t);\n    }, n.prototype.pack_int16 = function (t) {\n      this.bufferBuilder.append((65280 & t) >> 8), this.bufferBuilder.append(255 & t);\n    }, n.prototype.pack_int32 = function (t) {\n      this.bufferBuilder.append(t >>> 24 & 255), this.bufferBuilder.append((16711680 & t) >>> 16), this.bufferBuilder.append((65280 & t) >>> 8), this.bufferBuilder.append(255 & t);\n    }, n.prototype.pack_int64 = function (t) {\n      var e = Math.floor(t / Math.pow(2, 32)),\n          i = t % Math.pow(2, 32);\n      this.bufferBuilder.append((4278190080 & e) >>> 24), this.bufferBuilder.append((16711680 & e) >>> 16), this.bufferBuilder.append((65280 & e) >>> 8), this.bufferBuilder.append(255 & e), this.bufferBuilder.append((4278190080 & i) >>> 24), this.bufferBuilder.append((16711680 & i) >>> 16), this.bufferBuilder.append((65280 & i) >>> 8), this.bufferBuilder.append(255 & i);\n    };\n  }, {\n    \"./bufferbuilder\": \"vHo1\"\n  }],\n  \"sXtV\": [function (require, module, exports) {\n    \"use strict\";\n\n    exports.__esModule = !0, exports.RTCSessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription, exports.RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection, exports.RTCIceCandidate = window.RTCIceCandidate || window.mozRTCIceCandidate;\n  }, {}],\n  \"BHXf\": [function (require, module, exports) {\n    var global = arguments[3];\n\n    var e = arguments[3],\n        t = this && this.__importDefault || function (e) {\n      return e && e.__esModule ? e : {\n        default: e\n      };\n    };\n\n    exports.__esModule = !0;\n\n    var r = {\n      iceServers: [{\n        urls: \"stun:stun.l.google.com:19302\"\n      }]\n    },\n        o = 1,\n        n = t(require(\"js-binarypack\")),\n        a = require(\"./adapter\");\n\n    exports.util = {\n      noop: function noop() {},\n      CLOUD_HOST: \"0.peerjs.com\",\n      CLOUD_PORT: 443,\n      chunkedBrowsers: {\n        Chrome: 1\n      },\n      chunkedMTU: 16300,\n      logLevel: 0,\n      setLogLevel: function setLogLevel(e) {\n        var t = parseInt(e, 10);\n        isNaN(parseInt(e, 10)) ? exports.util.logLevel = e ? 3 : 0 : exports.util.logLevel = t, exports.util.log = exports.util.warn = exports.util.error = exports.util.noop, exports.util.logLevel > 0 && (exports.util.error = exports.util._printWith(\"ERROR\")), exports.util.logLevel > 1 && (exports.util.warn = exports.util._printWith(\"WARNING\")), exports.util.logLevel > 2 && (exports.util.log = exports.util._print);\n      },\n      setLogFunction: function setLogFunction(e) {\n        e.constructor !== Function ? exports.util.warn(\"The log function you passed in is not a function. Defaulting to regular logs.\") : exports.util._print = e;\n      },\n      _printWith: function _printWith(e) {\n        return function () {\n          var t = Array.prototype.slice.call(arguments);\n          t.unshift(e), exports.util._print.apply(exports.util, t);\n        };\n      },\n      _print: function _print() {\n        var e = !1,\n            t = Array.prototype.slice.call(arguments);\n        t.unshift(\"PeerJS: \");\n\n        for (var r = 0, o = t.length; r < o; r++) {\n          t[r] instanceof Error && (t[r] = \"(\" + t[r].name + \") \" + t[r].message, e = !0);\n        }\n\n        e ? console.error.apply(console, t) : console.log.apply(console, t);\n      },\n      defaultConfig: r,\n      browser: window.mozRTCPeerConnection ? \"Firefox\" : window.webkitRTCPeerConnection ? \"Chrome\" : window.RTCPeerConnection ? \"Supported\" : \"Unsupported\",\n      supports: function () {\n        if (void 0 === a.RTCPeerConnection) return {};\n        var e,\n            t,\n            o = !0,\n            n = !0,\n            i = !1,\n            u = !1,\n            l = !!window.webkitRTCPeerConnection;\n\n        try {\n          e = new a.RTCPeerConnection(r, {\n            optional: [{\n              RtpDataChannels: !0\n            }]\n          });\n        } catch (c) {\n          o = !1, n = !1;\n        }\n\n        if (o) try {\n          t = e.createDataChannel(\"_PEERJSTEST\");\n        } catch (c) {\n          o = !1;\n        }\n\n        if (o) {\n          try {\n            t.binaryType = \"blob\", i = !0;\n          } catch (c) {}\n\n          var s = new a.RTCPeerConnection(r, {});\n\n          try {\n            u = s.createDataChannel(\"_PEERJSRELIABLETEST\", {}).reliable;\n          } catch (c) {}\n\n          s.close();\n        }\n\n        return n && (n = !!e.addStream), e && e.close(), {\n          audioVideo: n,\n          data: o,\n          binaryBlob: i,\n          binary: u,\n          reliable: u,\n          sctp: u,\n          onnegotiationneeded: l\n        };\n      }(),\n      validateId: function validateId(e) {\n        return !e || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.exec(e);\n      },\n      validateKey: function validateKey(e) {\n        return !e || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.exec(e);\n      },\n      debug: !1,\n      inherits: function inherits(e, t) {\n        e.super_ = t, e.prototype = Object.create(t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        });\n      },\n      extend: function extend(e, t) {\n        for (var r in t) {\n          t.hasOwnProperty(r) && (e[r] = t[r]);\n        }\n\n        return e;\n      },\n      pack: n.default.pack,\n      unpack: n.default.unpack,\n      log: function log() {\n        if (exports.util.debug) {\n          var e = !1,\n              t = Array.prototype.slice.call(arguments);\n          t.unshift(\"PeerJS: \");\n\n          for (var r = 0, o = t.length; r < o; r++) {\n            t[r] instanceof Error && (t[r] = \"(\" + t[r].name + \") \" + t[r].message, e = !0);\n          }\n\n          e ? console.error.apply(console, t) : console.log.apply(console, t);\n        }\n      },\n      setZeroTimeout: function (e) {\n        var t = [],\n            r = \"zero-timeout-message\";\n\n        function o(o) {\n          o.source == e && o.data == r && (o.stopPropagation && o.stopPropagation(), t.length && t.shift()());\n        }\n\n        return e.addEventListener ? e.addEventListener(\"message\", o, !0) : e.attachEvent && e.attachEvent(\"onmessage\", o), function (o) {\n          t.push(o), e.postMessage(r, \"*\");\n        };\n      }(window),\n      chunk: function chunk(e) {\n        for (var t, r = [], n = e.size, a = t = 0, i = Math.ceil(n / exports.util.chunkedMTU); a < n;) {\n          var u = Math.min(n, a + exports.util.chunkedMTU),\n              l = e.slice(a, u),\n              s = {\n            __peerData: o,\n            n: t,\n            data: l,\n            total: i\n          };\n          r.push(s), a = u, t += 1;\n        }\n\n        return o += 1, r;\n      },\n      blobToArrayBuffer: function blobToArrayBuffer(e, t) {\n        var r = new FileReader();\n        r.onload = function (e) {\n          t(e.target.result);\n        }, r.readAsArrayBuffer(e);\n      },\n      blobToBinaryString: function blobToBinaryString(e, t) {\n        var r = new FileReader();\n        r.onload = function (e) {\n          t(e.target.result);\n        }, r.readAsBinaryString(e);\n      },\n      binaryStringToArrayBuffer: function binaryStringToArrayBuffer(e) {\n        for (var t = new Uint8Array(e.length), r = 0; r < e.length; r++) {\n          t[r] = 255 & e.charCodeAt(r);\n        }\n\n        return t.buffer;\n      },\n      randomToken: function randomToken() {\n        return Math.random().toString(36).substr(2);\n      },\n      isSecure: function isSecure() {\n        return \"https:\" === location.protocol;\n      }\n    };\n  }, {\n    \"js-binarypack\": \"lHOc\",\n    \"./adapter\": \"sXtV\"\n  }],\n  \"2JJl\": [function (require, module, exports) {\n    \"use strict\";\n\n    function t(t, e, n) {\n      this.fn = t, this.context = e, this.once = n || !1;\n    }\n\n    function e() {}\n\n    e.prototype._events = void 0, e.prototype.listeners = function (t) {\n      if (!this._events || !this._events[t]) return [];\n      if (this._events[t].fn) return [this._events[t].fn];\n\n      for (var e = 0, n = this._events[t].length, s = new Array(n); e < n; e++) {\n        s[e] = this._events[t][e].fn;\n      }\n\n      return s;\n    }, e.prototype.emit = function (t, e, n, s, r, i) {\n      if (!this._events || !this._events[t]) return !1;\n      var o,\n          h,\n          f = this._events[t],\n          v = arguments.length;\n\n      if (\"function\" == typeof f.fn) {\n        switch (f.once && this.removeListener(t, f.fn, !0), v) {\n          case 1:\n            return f.fn.call(f.context), !0;\n\n          case 2:\n            return f.fn.call(f.context, e), !0;\n\n          case 3:\n            return f.fn.call(f.context, e, n), !0;\n\n          case 4:\n            return f.fn.call(f.context, e, n, s), !0;\n\n          case 5:\n            return f.fn.call(f.context, e, n, s, r), !0;\n\n          case 6:\n            return f.fn.call(f.context, e, n, s, r, i), !0;\n        }\n\n        for (h = 1, o = new Array(v - 1); h < v; h++) {\n          o[h - 1] = arguments[h];\n        }\n\n        f.fn.apply(f.context, o);\n      } else {\n        var c,\n            a = f.length;\n\n        for (h = 0; h < a; h++) {\n          switch (f[h].once && this.removeListener(t, f[h].fn, !0), v) {\n            case 1:\n              f[h].fn.call(f[h].context);\n              break;\n\n            case 2:\n              f[h].fn.call(f[h].context, e);\n              break;\n\n            case 3:\n              f[h].fn.call(f[h].context, e, n);\n              break;\n\n            default:\n              if (!o) for (c = 1, o = new Array(v - 1); c < v; c++) {\n                o[c - 1] = arguments[c];\n              }\n              f[h].fn.apply(f[h].context, o);\n          }\n        }\n      }\n\n      return !0;\n    }, e.prototype.on = function (e, n, s) {\n      var r = new t(n, s || this);\n      return this._events || (this._events = {}), this._events[e] ? this._events[e].fn ? this._events[e] = [this._events[e], r] : this._events[e].push(r) : this._events[e] = r, this;\n    }, e.prototype.once = function (e, n, s) {\n      var r = new t(n, s || this, !0);\n      return this._events || (this._events = {}), this._events[e] ? this._events[e].fn ? this._events[e] = [this._events[e], r] : this._events[e].push(r) : this._events[e] = r, this;\n    }, e.prototype.removeListener = function (t, e, n) {\n      if (!this._events || !this._events[t]) return this;\n      var s = this._events[t],\n          r = [];\n      if (e && (s.fn && (s.fn !== e || n && !s.once) && r.push(s), !s.fn)) for (var i = 0, o = s.length; i < o; i++) {\n        (s[i].fn !== e || n && !s[i].once) && r.push(s[i]);\n      }\n      return r.length ? this._events[t] = 1 === r.length ? r[0] : r : delete this._events[t], this;\n    }, e.prototype.removeAllListeners = function (t) {\n      return this._events ? (t ? delete this._events[t] : this._events = {}, this) : this;\n    }, e.prototype.off = e.prototype.removeListener, e.prototype.addListener = e.prototype.on, e.prototype.setMaxListeners = function () {\n      return this;\n    }, e.EventEmitter = e, e.EventEmitter2 = e, e.EventEmitter3 = e, module.exports = e;\n  }, {}],\n  \"wJlv\": [function (require, module, exports) {\n    \"use strict\";\n\n    exports.__esModule = !0;\n\n    var t = require(\"./util\"),\n        e = require(\"eventemitter3\");\n\n    function s(t, i, o, n, r, h) {\n      if (!(this instanceof s)) return new s(t, i, o, n, r, h);\n      h = h || o, e.EventEmitter.call(this), this.disconnected = !1, this._queue = [];\n      var a = t ? \"https://\" : \"http://\",\n          u = t ? \"wss://\" : \"ws://\";\n      this._httpUrl = a + i + \":\" + o + n + r, this._wsUrl = u + i + \":\" + h + n + \"peerjs?key=\" + r;\n    }\n\n    exports.Socket = s, t.util.inherits(s, e.EventEmitter), s.prototype.start = function (t, e) {\n      this.id = t, this._httpUrl += \"/\" + t + \"/\" + e, this._wsUrl += \"&id=\" + t + \"&token=\" + e, this._startXhrStream(), this._startWebSocket();\n    }, s.prototype._startWebSocket = function (e) {\n      var s = this;\n      this._socket || (this._socket = new WebSocket(this._wsUrl), this._socket.onmessage = function (e) {\n        try {\n          var i = JSON.parse(e.data);\n        } catch (o) {\n          return void t.util.log(\"Invalid server message\", e.data);\n        }\n\n        s.emit(\"message\", i);\n      }, this._socket.onclose = function (e) {\n        t.util.log(\"Socket closed.\"), s.disconnected = !0, s.emit(\"disconnected\");\n      }, this._socket.onopen = function () {\n        s._timeout && (clearTimeout(s._timeout), setTimeout(function () {\n          s._http.abort(), s._http = null;\n        }, 5e3)), s._sendQueuedMessages(), t.util.log(\"Socket open\");\n      });\n    }, s.prototype._startXhrStream = function (e) {\n      try {\n        var s = this;\n        this._http = new XMLHttpRequest(), this._http._index = 1, this._http._streamIndex = e || 0, this._http.open(\"post\", this._httpUrl + \"/id?i=\" + this._http._streamIndex, !0), this._http.onerror = function () {\n          clearTimeout(s._timeout), s.emit(\"disconnected\");\n        }, this._http.onreadystatechange = function () {\n          2 == this.readyState && this.old ? (this.old.abort(), delete this.old) : this.readyState > 2 && 200 === this.status && this.responseText && s._handleStream(this);\n        }, this._http.send(null), this._setHTTPTimeout();\n      } catch (i) {\n        t.util.log(\"XMLHttpRequest not available; defaulting to WebSockets\");\n      }\n    }, s.prototype._handleStream = function (e) {\n      var s = e.responseText.split(\"\\n\");\n      if (e._buffer) for (; e._buffer.length > 0;) {\n        var i = e._buffer.shift(),\n            o = s[i];\n\n        try {\n          o = JSON.parse(o);\n        } catch (r) {\n          e._buffer.shift(i);\n\n          break;\n        }\n\n        this.emit(\"message\", o);\n      }\n      var n = s[e._index];\n      if (n) if (e._index += 1, e._index === s.length) e._buffer || (e._buffer = []), e._buffer.push(e._index - 1);else {\n        try {\n          n = JSON.parse(n);\n        } catch (r) {\n          return void t.util.log(\"Invalid server message\", n);\n        }\n\n        this.emit(\"message\", n);\n      }\n    }, s.prototype._setHTTPTimeout = function () {\n      var t = this;\n      this._timeout = setTimeout(function () {\n        var e = t._http;\n        t._wsOpen() ? e.abort() : (t._startXhrStream(e._streamIndex + 1), t._http.old = e);\n      }, 25e3);\n    }, s.prototype._wsOpen = function () {\n      return this._socket && 1 == this._socket.readyState;\n    }, s.prototype._sendQueuedMessages = function () {\n      for (var t = 0, e = this._queue.length; t < e; t += 1) {\n        this.send(this._queue[t]);\n      }\n    }, s.prototype.send = function (t) {\n      if (!this.disconnected) if (this.id) {\n        if (t.type) {\n          var e = JSON.stringify(t);\n          if (this._wsOpen()) this._socket.send(e);else {\n            var s = new XMLHttpRequest(),\n                i = this._httpUrl + \"/\" + t.type.toLowerCase();\n            s.open(\"post\", i, !0), s.setRequestHeader(\"Content-Type\", \"application/json\"), s.send(e);\n          }\n        } else this.emit(\"error\", \"Invalid message\");\n      } else this._queue.push(t);\n    }, s.prototype.close = function () {\n      !this.disconnected && this._wsOpen() && (this._socket.close(), this.disconnected = !0);\n    };\n  }, {\n    \"./util\": \"BHXf\",\n    \"eventemitter3\": \"2JJl\"\n  }],\n  \"HCdX\": [function (require, module, exports) {\n    \"use strict\";\n\n    exports.__esModule = !0;\n\n    var e = require(\"./util\"),\n        t = require(\"./adapter\");\n\n    function o(e, t) {\n      \"addTrack\" in t ? e.getTracks().forEach(function (o) {\n        t.addTrack(o, e);\n      }) : \"addStream\" in t && t.addStream(e);\n    }\n\n    exports.Negotiator = {\n      pcs: {\n        data: {},\n        media: {}\n      },\n      queue: []\n    }, exports.Negotiator._idPrefix = \"pc_\", exports.Negotiator.startConnection = function (t, i) {\n      var r = exports.Negotiator._getPeerConnection(t, i);\n\n      if (t.pc = t.peerConnection = r, \"media\" === t.type && i._stream && o(i._stream, r), i.originator) {\n        if (\"data\" === t.type) {\n          var n = {};\n          e.util.supports.sctp || (n = {\n            reliable: i.reliable\n          });\n          var a = r.createDataChannel(t.label, n);\n          t.initialize(a);\n        }\n\n        exports.Negotiator._makeOffer(t);\n      } else exports.Negotiator.handleSDP(\"OFFER\", t, i.sdp);\n    }, exports.Negotiator._getPeerConnection = function (t, o) {\n      exports.Negotiator.pcs[t.type] || e.util.error(t.type + \" is not a valid connection type. Maybe you overrode the `type` property somewhere.\"), exports.Negotiator.pcs[t.type][t.peer] || (exports.Negotiator.pcs[t.type][t.peer] = {});\n      var i;\n      exports.Negotiator.pcs[t.type][t.peer];\n      return o.pc && (i = exports.Negotiator.pcs[t.type][t.peer][o.pc]), i && \"stable\" === i.signalingState || (i = exports.Negotiator._startPeerConnection(t)), i;\n    }, exports.Negotiator._startPeerConnection = function (o) {\n      e.util.log(\"Creating RTCPeerConnection.\");\n      var i = exports.Negotiator._idPrefix + e.util.randomToken(),\n          r = {};\n      \"data\" !== o.type || e.util.supports.sctp ? \"media\" === o.type && (r = {\n        optional: [{\n          DtlsSrtpKeyAgreement: !0\n        }]\n      }) : r = {\n        optional: [{\n          RtpDataChannels: !0\n        }]\n      };\n      var n = new t.RTCPeerConnection(o.provider.options.config, r);\n      return exports.Negotiator.pcs[o.type][o.peer][i] = n, exports.Negotiator._setupListeners(o, n, i), n;\n    }, exports.Negotiator._setupListeners = function (t, i, r) {\n      var n = t.peer,\n          a = t.id,\n          c = t.provider;\n      e.util.log(\"Listening for ICE candidates.\"), i.onicecandidate = function (o) {\n        o.candidate && (e.util.log(\"Received ICE candidates for:\", t.peer), c.socket.send({\n          type: \"CANDIDATE\",\n          payload: {\n            candidate: o.candidate,\n            type: t.type,\n            connectionId: t.id\n          },\n          dst: n\n        }));\n      }, i.oniceconnectionstatechange = function () {\n        switch (i.iceConnectionState) {\n          case \"failed\":\n            e.util.log(\"iceConnectionState is disconnected, closing connections to \" + n), t.emit(\"error\", new Error(\"Negotiation of connection to \" + n + \" failed.\")), t.close();\n            break;\n\n          case \"disconnected\":\n            e.util.log(\"iceConnectionState is disconnected, closing connections to \" + n);\n            break;\n\n          case \"completed\":\n            i.onicecandidate = e.util.noop;\n        }\n      }, i.onicechange = i.oniceconnectionstatechange, e.util.log(\"Listening for data channel\"), i.ondatachannel = function (t) {\n        e.util.log(\"Received data channel\");\n        var o = t.channel;\n        c.getConnection(n, a).initialize(o);\n      }, e.util.log(\"Listening for remote stream\"), i.ontrack = function (t) {\n        e.util.log(\"Received remote stream\");\n        var i = t.streams[0],\n            r = c.getConnection(n, a);\n        \"media\" === r.type && o(i, r);\n      };\n    }, exports.Negotiator.cleanup = function (t) {\n      e.util.log(\"Cleaning up PeerConnection to \" + t.peer);\n      var o = t.pc;\n      o && (o.readyState && \"closed\" !== o.readyState || \"closed\" !== o.signalingState) && (o.close(), t.pc = null);\n    }, exports.Negotiator._makeOffer = function (t) {\n      var o = t.pc,\n          i = function i(_i) {\n        e.util.log(\"Created offer.\"), !e.util.supports.sctp && \"data\" === t.type && t.reliable && (_i.sdp = Reliable.higherBandwidthSDP(_i.sdp));\n        o.setLocalDescription(_i).then(function () {\n          return e.util.log(\"Set localDescription: offer\", \"for:\", t.peer), void t.provider.socket.send({\n            type: \"OFFER\",\n            payload: {\n              sdp: _i,\n              type: t.type,\n              label: t.label,\n              connectionId: t.id,\n              reliable: t.reliable,\n              serialization: t.serialization,\n              metadata: t.metadata,\n              browser: e.util.browser\n            },\n            dst: t.peer\n          });\n        }).catch(function (o) {\n          return function (o) {\n            \"OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer\" != o && (t.provider.emitError(\"webrtc\", o), e.util.log(\"Failed to setLocalDescription, \", o));\n          }(o);\n        });\n      };\n\n      o.createOffer(t.options.constraints).then(function (e) {\n        return i(e);\n      }).catch(function (o) {\n        return function (o) {\n          t.provider.emitError(\"webrtc\", o), e.util.log(\"Failed to createOffer, \", o);\n        }(o);\n      });\n    }, exports.Negotiator._makeAnswer = function (t) {\n      var o = t.pc,\n          i = function i(_i2) {\n        e.util.log(\"Created answer.\"), !e.util.supports.sctp && \"data\" === t.type && t.reliable && (_i2.sdp = Reliable.higherBandwidthSDP(_i2.sdp));\n        o.setLocalDescription(_i2).then(function () {\n          return e.util.log(\"Set localDescription: answer\", \"for:\", t.peer), void t.provider.socket.send({\n            type: \"ANSWER\",\n            payload: {\n              sdp: _i2,\n              type: t.type,\n              connectionId: t.id,\n              browser: e.util.browser\n            },\n            dst: t.peer\n          });\n        }).catch(function (o) {\n          t.provider.emitError(\"webrtc\", o), e.util.log(\"Failed to setLocalDescription, \", o);\n        });\n      };\n\n      o.createAnswer().then(function (e) {\n        return i(e);\n      }).catch(function (o) {\n        t.provider.emitError(\"webrtc\", o), e.util.log(\"Failed to create answer, \", o);\n      });\n    }, exports.Negotiator.handleSDP = function (o, i, r) {\n      r = new t.RTCSessionDescription(r);\n      var n = i.pc;\n      e.util.log(\"Setting remote description\", r);\n      n.setRemoteDescription(r).then(function () {\n        return e.util.log(\"Set remoteDescription:\", o, \"for:\", i.peer), void (\"OFFER\" === o && exports.Negotiator._makeAnswer(i));\n      }).catch(function (t) {\n        i.provider.emitError(\"webrtc\", t), e.util.log(\"Failed to setRemoteDescription, \", t);\n      });\n    }, exports.Negotiator.handleCandidate = function (o, i) {\n      var r = i.candidate,\n          n = i.sdpMLineIndex;\n      o.pc.addIceCandidate(new t.RTCIceCandidate({\n        sdpMLineIndex: n,\n        candidate: r\n      })), e.util.log(\"Added ICE candidate for:\", o.peer);\n    };\n  }, {\n    \"./util\": \"BHXf\",\n    \"./adapter\": \"sXtV\"\n  }],\n  \"dbHP\": [function (require, module, exports) {\n    \"use strict\";\n\n    exports.__esModule = !0;\n\n    var t = require(\"./util\"),\n        e = require(\"eventemitter3\"),\n        i = require(\"./negotiator\");\n\n    function o(s, a, r) {\n      if (!(this instanceof o)) return new o(s, a, r);\n      e.EventEmitter.call(this), this.options = t.util.extend({}, r), this.open = !1, this.type = \"media\", this.peer = s, this.provider = a, this.metadata = this.options.metadata, this.localStream = this.options._stream, this.id = this.options.connectionId || o._idPrefix + t.util.randomToken(), this.localStream && i.Negotiator.startConnection(this, {\n        _stream: this.localStream,\n        originator: !0\n      });\n    }\n\n    exports.MediaConnection = o, t.util.inherits(o, e.EventEmitter), o._idPrefix = \"mc_\", o.prototype.addStream = function (e) {\n      t.util.log(\"Receiving stream\", e), this.remoteStream = e, this.emit(\"stream\", e);\n    }, o.prototype.handleMessage = function (e) {\n      var o = e.payload;\n\n      switch (e.type) {\n        case \"ANSWER\":\n          i.Negotiator.handleSDP(e.type, this, o.sdp), this.open = !0;\n          break;\n\n        case \"CANDIDATE\":\n          i.Negotiator.handleCandidate(this, o.candidate);\n          break;\n\n        default:\n          t.util.warn(\"Unrecognized message type:\", e.type, \"from peer:\", this.peer);\n      }\n    }, o.prototype.answer = function (e) {\n      if (this.localStream) t.util.warn(\"Local stream already exists on this MediaConnection. Are you answering a call twice?\");else {\n        this.options._payload._stream = e, this.localStream = e, i.Negotiator.startConnection(this, this.options._payload);\n\n        for (var o = this.provider._getMessages(this.id), s = 0, a = o.length; s < a; s += 1) {\n          this.handleMessage(o[s]);\n        }\n\n        this.open = !0;\n      }\n    }, o.prototype.close = function () {\n      this.open && (this.open = !1, i.Negotiator.cleanup(this), this.emit(\"close\"));\n    };\n  }, {\n    \"./util\": \"BHXf\",\n    \"eventemitter3\": \"2JJl\",\n    \"./negotiator\": \"HCdX\"\n  }],\n  \"T9kO\": [function (require, module, exports) {\n    var global = arguments[3];\n\n    var e = arguments[3],\n        r = require(\"js-binarypack\"),\n        t = {\n      debug: !1,\n      inherits: function inherits(e, r) {\n        e.super_ = r, e.prototype = Object.create(r.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        });\n      },\n      extend: function extend(e, r) {\n        for (var t in r) {\n          r.hasOwnProperty(t) && (e[t] = r[t]);\n        }\n\n        return e;\n      },\n      pack: r.pack,\n      unpack: r.unpack,\n      log: function log() {\n        if (t.debug) {\n          for (var e = [], r = 0; r < arguments.length; r++) {\n            e[r] = arguments[r];\n          }\n\n          e.unshift(\"Reliable: \"), console.log.apply(console, e);\n        }\n      },\n      setZeroTimeout: function (e) {\n        var r = [],\n            t = \"zero-timeout-message\";\n\n        function n(n) {\n          n.source == e && n.data == t && (n.stopPropagation && n.stopPropagation(), r.length && r.shift()());\n        }\n\n        return e.addEventListener ? e.addEventListener(\"message\", n, !0) : e.attachEvent && e.attachEvent(\"onmessage\", n), function (n) {\n          r.push(n), e.postMessage(t, \"*\");\n        };\n      }(this),\n      blobToArrayBuffer: function blobToArrayBuffer(e, r) {\n        var t = new FileReader();\n        t.onload = function (e) {\n          r(e.target.result);\n        }, t.readAsArrayBuffer(e);\n      },\n      blobToBinaryString: function blobToBinaryString(e, r) {\n        var t = new FileReader();\n        t.onload = function (e) {\n          r(e.target.result);\n        }, t.readAsBinaryString(e);\n      },\n      binaryStringToArrayBuffer: function binaryStringToArrayBuffer(e) {\n        for (var r = new Uint8Array(e.length), t = 0; t < e.length; t++) {\n          r[t] = 255 & e.charCodeAt(t);\n        }\n\n        return r.buffer;\n      },\n      randomToken: function randomToken() {\n        return Math.random().toString(36).substr(2);\n      }\n    };\n\n    module.exports = t;\n  }, {\n    \"js-binarypack\": \"lHOc\"\n  }],\n  \"aYFJ\": [function (require, module, exports) {\n    var t = require(\"./util\");\n\n    function e(n, i) {\n      if (!(this instanceof e)) return new e(n);\n      this._dc = n, t.debug = i, this._outgoing = {}, this._incoming = {}, this._received = {}, this._window = 1e3, this._mtu = 500, this._interval = 0, this._count = 0, this._queue = [], this._setupDC();\n    }\n\n    e.prototype.send = function (e) {\n      var n = t.pack(e);\n      n.size < this._mtu ? this._handleSend([\"no\", n]) : (this._outgoing[this._count] = {\n        ack: 0,\n        chunks: this._chunk(n)\n      }, t.debug && (this._outgoing[this._count].timer = new Date()), this._sendWindowedChunks(this._count), this._count += 1);\n    }, e.prototype._setupInterval = function () {\n      var t = this;\n      this._timeout = setInterval(function () {\n        var e = t._queue.shift();\n\n        if (e._multiple) for (var n = 0, i = e.length; n < i; n += 1) {\n          t._intervalSend(e[n]);\n        } else t._intervalSend(e);\n      }, this._interval);\n    }, e.prototype._intervalSend = function (e) {\n      var n = this;\n      e = t.pack(e), t.blobToBinaryString(e, function (t) {\n        n._dc.send(t);\n      }), 0 === n._queue.length && (clearTimeout(n._timeout), n._timeout = null);\n    }, e.prototype._processAcks = function () {\n      for (var t in this._outgoing) {\n        this._outgoing.hasOwnProperty(t) && this._sendWindowedChunks(t);\n      }\n    }, e.prototype._handleSend = function (t) {\n      for (var e = !0, n = 0, i = this._queue.length; n < i; n += 1) {\n        var o = this._queue[n];\n        o === t ? e = !1 : o._multiple && -1 !== o.indexOf(t) && (e = !1);\n      }\n\n      e && (this._queue.push(t), this._timeout || this._setupInterval());\n    }, e.prototype._setupDC = function () {\n      var e = this;\n\n      this._dc.onmessage = function (n) {\n        var i = n.data;\n\n        if (i.constructor === String) {\n          var o = t.binaryStringToArrayBuffer(i);\n          i = t.unpack(o), e._handleMessage(i);\n        }\n      };\n    }, e.prototype._handleMessage = function (e) {\n      var n,\n          i = e[1],\n          o = this._incoming[i],\n          s = this._outgoing[i];\n\n      switch (e[0]) {\n        case \"no\":\n          var a = i;\n          a && this.onmessage(t.unpack(a));\n          break;\n\n        case \"end\":\n          if (n = o, this._received[i] = e[2], !n) break;\n\n          this._ack(i);\n\n          break;\n\n        case \"ack\":\n          if (n = s) {\n            var h = e[2];\n            n.ack = Math.max(h, n.ack), n.ack >= n.chunks.length ? (t.log(\"Time: \", new Date() - n.timer), delete this._outgoing[i]) : this._processAcks();\n          }\n\n          break;\n\n        case \"chunk\":\n          if (!(n = o)) {\n            if (!0 === this._received[i]) break;\n            n = {\n              ack: [\"ack\", i, 0],\n              chunks: []\n            }, this._incoming[i] = n;\n          }\n\n          var r = e[2],\n              u = e[3];\n          n.chunks[r] = new Uint8Array(u), r === n.ack[2] && this._calculateNextAck(i), this._ack(i);\n          break;\n\n        default:\n          this._handleSend(e);\n\n      }\n    }, e.prototype._chunk = function (e) {\n      for (var n = [], i = e.size, o = 0; o < i;) {\n        var s = Math.min(i, o + this._mtu),\n            a = {\n          payload: e.slice(o, s)\n        };\n        n.push(a), o = s;\n      }\n\n      return t.log(\"Created\", n.length, \"chunks.\"), n;\n    }, e.prototype._ack = function (t) {\n      var e = this._incoming[t].ack;\n      this._received[t] === e[2] && (this._complete(t), this._received[t] = !0), this._handleSend(e);\n    }, e.prototype._calculateNextAck = function (t) {\n      for (var e = this._incoming[t], n = e.chunks, i = 0, o = n.length; i < o; i += 1) {\n        if (void 0 === n[i]) return void (e.ack[2] = i);\n      }\n\n      e.ack[2] = n.length;\n    }, e.prototype._sendWindowedChunks = function (e) {\n      t.log(\"sendWindowedChunks for: \", e);\n\n      for (var n = this._outgoing[e], i = n.chunks, o = [], s = Math.min(n.ack + this._window, i.length), a = n.ack; a < s; a += 1) {\n        i[a].sent && a !== n.ack || (i[a].sent = !0, o.push([\"chunk\", e, a, i[a].payload]));\n      }\n\n      n.ack + this._window >= i.length && o.push([\"end\", e, i.length]), o._multiple = !0, this._handleSend(o);\n    }, e.prototype._complete = function (e) {\n      t.log(\"Completed called for\", e);\n      var n = this,\n          i = this._incoming[e].chunks,\n          o = new Blob(i);\n      t.blobToArrayBuffer(o, function (e) {\n        n.onmessage(t.unpack(e));\n      }), delete this._incoming[e];\n    }, e.higherBandwidthSDP = function (t) {\n      var e = navigator.appVersion.match(/Chrome\\/(.*?) /);\n\n      if (e && (e = parseInt(e[1].split(\".\").shift())) < 31) {\n        var n = t.split(\"b=AS:30\");\n        if (n.length > 1) return n[0] + \"b=AS:102400\" + n[1];\n      }\n\n      return t;\n    }, e.prototype.onmessage = function (t) {}, module.exports.Reliable = e;\n  }, {\n    \"./util\": \"T9kO\"\n  }],\n  \"GBTQ\": [function (require, module, exports) {\n    \"use strict\";\n\n    exports.__esModule = !0;\n\n    var t = require(\"./util\"),\n        e = require(\"eventemitter3\"),\n        i = require(\"./negotiator\"),\n        n = require(\"reliable\");\n\n    function s(n, r, a) {\n      if (!(this instanceof s)) return new s(n, r, a);\n      e.EventEmitter.call(this), this.options = t.util.extend({\n        serialization: \"binary\",\n        reliable: !1\n      }, a), this.open = !1, this.type = \"data\", this.peer = n, this.provider = r, this.id = this.options.connectionId || s._idPrefix + t.util.randomToken(), this.label = this.options.label || this.id, this.metadata = this.options.metadata, this.serialization = this.options.serialization, this.reliable = this.options.reliable, this._buffer = [], this._buffering = !1, this.bufferSize = 0, this._chunkedData = {}, this.options._payload && (this._peerBrowser = this.options._payload.browser), i.Negotiator.startConnection(this, this.options._payload || {\n        originator: !0\n      });\n    }\n\n    exports.DataConnection = s, t.util.inherits(s, e.EventEmitter), s._idPrefix = \"dc_\", s.prototype.initialize = function (t) {\n      this._dc = this.dataChannel = t, this._configureDataChannel();\n    }, s.prototype._configureDataChannel = function () {\n      var e = this;\n      t.util.supports.sctp && (this._dc.binaryType = \"arraybuffer\"), this._dc.onopen = function () {\n        t.util.log(\"Data channel connection success\"), e.open = !0, e.emit(\"open\");\n      }, !t.util.supports.sctp && this.reliable && (this._reliable = new n.Reliable(this._dc, t.util.debug)), this._reliable ? this._reliable.onmessage = function (t) {\n        e.emit(\"data\", t);\n      } : this._dc.onmessage = function (t) {\n        e._handleDataMessage(t);\n      }, this._dc.onclose = function (i) {\n        t.util.log(\"DataChannel closed for:\", e.peer), e.close();\n      };\n    }, s.prototype._handleDataMessage = function (e) {\n      var i = this,\n          n = e.data,\n          s = n.constructor;\n\n      if (\"binary\" === this.serialization || \"binary-utf8\" === this.serialization) {\n        if (s === Blob) return void t.util.blobToArrayBuffer(n, function (e) {\n          n = t.util.unpack(e), i.emit(\"data\", n);\n        });\n        if (s === ArrayBuffer) n = t.util.unpack(n);else if (s === String) {\n          var r = t.util.binaryStringToArrayBuffer(n);\n          n = t.util.unpack(r);\n        }\n      } else \"json\" === this.serialization && (n = JSON.parse(n));\n\n      if (n.__peerData) {\n        var a = n.__peerData,\n            o = this._chunkedData[a] || {\n          data: [],\n          count: 0,\n          total: n.total\n        };\n        return o.data[n.n] = n.data, o.count += 1, o.total === o.count && (delete this._chunkedData[a], n = new Blob(o.data), this._handleDataMessage({\n          data: n\n        })), void (this._chunkedData[a] = o);\n      }\n\n      this.emit(\"data\", n);\n    }, s.prototype.close = function () {\n      this.open && (this.open = !1, i.Negotiator.cleanup(this), this.emit(\"close\"));\n    }, s.prototype.send = function (e, i) {\n      if (this.open) {\n        if (this._reliable) this._reliable.send(e);else {\n          var n = this;\n          if (\"json\" === this.serialization) this._bufferedSend(JSON.stringify(e));else if (\"binary\" === this.serialization || \"binary-utf8\" === this.serialization) {\n            var s = t.util.pack(e);\n            if ((t.util.chunkedBrowsers[this._peerBrowser] || t.util.chunkedBrowsers[t.util.browser]) && !i && s.size > t.util.chunkedMTU) return void this._sendChunks(s);\n            t.util.supports.sctp ? t.util.supports.binaryBlob ? this._bufferedSend(s) : t.util.blobToArrayBuffer(s, function (t) {\n              n._bufferedSend(t);\n            }) : t.util.blobToBinaryString(s, function (t) {\n              n._bufferedSend(t);\n            });\n          } else this._bufferedSend(e);\n        }\n      } else this.emit(\"error\", new Error(\"Connection is not open. You should listen for the `open` event before sending messages.\"));\n    }, s.prototype._bufferedSend = function (t) {\n      !this._buffering && this._trySend(t) || (this._buffer.push(t), this.bufferSize = this._buffer.length);\n    }, s.prototype._trySend = function (t) {\n      try {\n        this._dc.send(t);\n      } catch (i) {\n        this._buffering = !0;\n        var e = this;\n        return setTimeout(function () {\n          e._buffering = !1, e._tryBuffer();\n        }, 100), !1;\n      }\n\n      return !0;\n    }, s.prototype._tryBuffer = function () {\n      if (0 !== this._buffer.length) {\n        var t = this._buffer[0];\n        this._trySend(t) && (this._buffer.shift(), this.bufferSize = this._buffer.length, this._tryBuffer());\n      }\n    }, s.prototype._sendChunks = function (e) {\n      for (var i = t.util.chunk(e), n = 0, s = i.length; n < s; n += 1) {\n        e = i[n];\n        this.send(e, !0);\n      }\n    }, s.prototype.handleMessage = function (e) {\n      var n = e.payload;\n\n      switch (e.type) {\n        case \"ANSWER\":\n          this._peerBrowser = n.browser, i.Negotiator.handleSDP(e.type, this, n.sdp);\n          break;\n\n        case \"CANDIDATE\":\n          i.Negotiator.handleCandidate(this, n.candidate);\n          break;\n\n        default:\n          t.util.warn(\"Unrecognized message type:\", e.type, \"from peer:\", this.peer);\n      }\n    };\n  }, {\n    \"./util\": \"BHXf\",\n    \"eventemitter3\": \"2JJl\",\n    \"./negotiator\": \"HCdX\",\n    \"reliable\": \"aYFJ\"\n  }],\n  \"Hxpd\": [function (require, module, exports) {\n    \"use strict\";\n\n    exports.__esModule = !0;\n\n    var e = require(\"./util\"),\n        t = require(\"eventemitter3\"),\n        o = require(\"./socket\"),\n        n = require(\"./mediaconnection\"),\n        i = require(\"./dataconnection\");\n\n    function s(o, n) {\n      if (!(this instanceof s)) return new s(o, n);\n      t.EventEmitter.call(this), o && o.constructor == Object ? (n = o, o = void 0) : o && (o = o.toString()), (n = e.util.extend({\n        debug: 0,\n        host: e.util.CLOUD_HOST,\n        port: e.util.CLOUD_PORT,\n        path: \"/\",\n        token: e.util.randomToken(),\n        config: e.util.defaultConfig\n      }, n)).key = \"peerjs\", this.options = n, \"/\" === n.host && (n.host = window.location.hostname), \"/\" !== n.path[0] && (n.path = \"/\" + n.path), \"/\" !== n.path[n.path.length - 1] && (n.path += \"/\"), void 0 === n.secure && n.host !== e.util.CLOUD_HOST ? n.secure = e.util.isSecure() : n.host == e.util.CLOUD_HOST && (n.secure = !0), n.logFunction && e.util.setLogFunction(n.logFunction), e.util.setLogLevel(n.debug), e.util.supports.audioVideo || e.util.supports.data ? e.util.validateId(o) ? (this.destroyed = !1, this.disconnected = !1, this.open = !1, this.connections = {}, this._lostMessages = {}, this._initializeServerConnection(), o ? this._initialize(o) : this._retrieveId()) : this._delayedAbort(\"invalid-id\", 'ID \"' + o + '\" is invalid') : this._delayedAbort(\"browser-incompatible\", \"The current browser does not support WebRTC\");\n    }\n\n    exports.Peer = s, e.util.inherits(s, t.EventEmitter), s.prototype._initializeServerConnection = function () {\n      var e = this;\n      this.socket = new o.Socket(this.options.secure, this.options.host, this.options.port, this.options.path, this.options.key, this.options.wsport), this.socket.on(\"message\", function (t) {\n        e._handleMessage(t);\n      }), this.socket.on(\"error\", function (t) {\n        e._abort(\"socket-error\", t);\n      }), this.socket.on(\"disconnected\", function () {\n        e.disconnected || (e.emitError(\"network\", \"Lost connection to server.\"), e.disconnect());\n      }), this.socket.on(\"close\", function () {\n        e.disconnected || e._abort(\"socket-closed\", \"Underlying socket is already closed.\");\n      });\n    }, s.prototype._retrieveId = function (t) {\n      var o = this,\n          n = new XMLHttpRequest(),\n          i = (this.options.secure ? \"https://\" : \"http://\") + this.options.host + \":\" + this.options.port + this.options.path + this.options.key + \"/id\";\n      i += \"?ts=\" + new Date().getTime() + Math.random(), n.open(\"get\", i, !0), n.onerror = function (t) {\n        e.util.error(\"Error retrieving ID\", t);\n        var n = \"\";\n        \"/\" === o.options.path && o.options.host !== e.util.CLOUD_HOST && (n = \" If you passed in a `path` to your self-hosted PeerServer, you'll also need to pass in that same path when creating a new Peer.\"), o._abort(\"server-error\", \"Could not get an ID from the server.\" + n);\n      }, n.onreadystatechange = function () {\n        4 === n.readyState && (200 === n.status ? o._initialize(n.responseText) : n.onerror());\n      }, n.send(null);\n    }, s.prototype._initialize = function (e) {\n      this.id = e, this.socket.start(this.id, this.options.token);\n    }, s.prototype._handleMessage = function (t) {\n      var o,\n          s = t.type,\n          r = t.payload,\n          a = t.src;\n\n      switch (s) {\n        case \"OPEN\":\n          this.emit(\"open\", this.id), this.open = !0;\n          break;\n\n        case \"ERROR\":\n          this._abort(\"server-error\", r.msg);\n\n          break;\n\n        case \"ID-TAKEN\":\n          this._abort(\"unavailable-id\", \"ID `\" + this.id + \"` is taken\");\n\n          break;\n\n        case \"INVALID-KEY\":\n          this._abort(\"invalid-key\", 'API KEY \"' + this.options.key + '\" is invalid');\n\n          break;\n\n        case \"LEAVE\":\n          e.util.log(\"Received leave message from\", a), this._cleanupPeer(a);\n          break;\n\n        case \"EXPIRE\":\n          this.emitError(\"peer-unavailable\", \"Could not connect to peer \" + a);\n          break;\n\n        case \"OFFER\":\n          var c = r.connectionId;\n          if ((o = this.getConnection(a, c)) && (o.close(), e.util.warn(\"Offer received for existing Connection ID:\", c)), \"media\" === r.type) o = new n.MediaConnection(a, this, {\n            connectionId: c,\n            _payload: r,\n            metadata: r.metadata\n          }), this._addConnection(a, o), this.emit(\"call\", o);else {\n            if (\"data\" !== r.type) return void e.util.warn(\"Received malformed connection type:\", r.type);\n            o = new i.DataConnection(a, this, {\n              connectionId: c,\n              _payload: r,\n              metadata: r.metadata,\n              label: r.label,\n              serialization: r.serialization,\n              reliable: r.reliable\n            }), this._addConnection(a, o), this.emit(\"connection\", o);\n          }\n\n          for (var h = this._getMessages(c), d = 0, l = h.length; d < l; d += 1) {\n            o.handleMessage(h[d]);\n          }\n\n          break;\n\n        default:\n          if (!r) return void e.util.warn(\"You received a malformed message from \" + a + \" of type \" + s);\n          var u = r.connectionId;\n          (o = this.getConnection(a, u)) && o.pc ? o.handleMessage(t) : u ? this._storeMessage(u, t) : e.util.warn(\"You received an unrecognized message:\", t);\n      }\n    }, s.prototype._storeMessage = function (e, t) {\n      this._lostMessages[e] || (this._lostMessages[e] = []), this._lostMessages[e].push(t);\n    }, s.prototype._getMessages = function (e) {\n      var t = this._lostMessages[e];\n      return t ? (delete this._lostMessages[e], t) : [];\n    }, s.prototype.connect = function (t, o) {\n      if (this.disconnected) return e.util.warn(\"You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect, or call reconnect on this peer if you believe its ID to still be available.\"), void this.emitError(\"disconnected\", \"Cannot connect to new Peer after disconnecting from server.\");\n      var n = new i.DataConnection(t, this, o);\n      return this._addConnection(t, n), n;\n    }, s.prototype.call = function (t, o, i) {\n      if (this.disconnected) return e.util.warn(\"You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect.\"), void this.emitError(\"disconnected\", \"Cannot connect to new Peer after disconnecting from server.\");\n\n      if (o) {\n        (i = i || {})._stream = o;\n        var s = new n.MediaConnection(t, this, i);\n        return this._addConnection(t, s), s;\n      }\n\n      e.util.error(\"To call a peer, you must provide a stream from your browser's `getUserMedia`.\");\n    }, s.prototype._addConnection = function (e, t) {\n      this.connections[e] || (this.connections[e] = []), this.connections[e].push(t);\n    }, s.prototype.getConnection = function (e, t) {\n      var o = this.connections[e];\n      if (!o) return null;\n\n      for (var n = 0, i = o.length; n < i; n++) {\n        if (o[n].id === t) return o[n];\n      }\n\n      return null;\n    }, s.prototype._delayedAbort = function (t, o) {\n      var n = this;\n      e.util.setZeroTimeout(function () {\n        n._abort(t, o);\n      });\n    }, s.prototype._abort = function (t, o) {\n      e.util.error(\"Aborting!\"), this._lastServerId ? this.disconnect() : this.destroy(), this.emitError(t, o);\n    }, s.prototype.emitError = function (t, o) {\n      e.util.error(\"Error:\", o), \"string\" == typeof o && (o = new Error(o)), o.type = t, this.emit(\"error\", o);\n    }, s.prototype.destroy = function () {\n      this.destroyed || (this._cleanup(), this.disconnect(), this.destroyed = !0);\n    }, s.prototype._cleanup = function () {\n      if (this.connections) for (var e = Object.keys(this.connections), t = 0, o = e.length; t < o; t++) {\n        this._cleanupPeer(e[t]);\n      }\n      this.emit(\"close\");\n    }, s.prototype._cleanupPeer = function (e) {\n      for (var t = this.connections[e], o = 0, n = t.length; o < n; o += 1) {\n        t[o].close();\n      }\n    }, s.prototype.disconnect = function () {\n      var t = this;\n      e.util.setZeroTimeout(function () {\n        t.disconnected || (t.disconnected = !0, t.open = !1, t.socket && t.socket.close(), t.emit(\"disconnected\", t.id), t._lastServerId = t.id, t.id = null);\n      });\n    }, s.prototype.reconnect = function () {\n      if (this.disconnected && !this.destroyed) e.util.log(\"Attempting reconnection to server with ID \" + this._lastServerId), this.disconnected = !1, this._initializeServerConnection(), this._initialize(this._lastServerId);else {\n        if (this.destroyed) throw new Error(\"This peer cannot reconnect to the server. It has already been destroyed.\");\n        if (this.disconnected || this.open) throw new Error(\"Peer \" + this.id + \" cannot reconnect because it is not disconnected from the server!\");\n        e.util.error(\"In a hurry? We're still trying to make the initial connection!\");\n      }\n    }, s.prototype.listAllPeers = function (t) {\n      t = t || function () {};\n\n      var o = this,\n          n = new XMLHttpRequest(),\n          i = (this.options.secure ? \"https://\" : \"http://\") + this.options.host + \":\" + this.options.port + this.options.path + this.options.key + \"/peers\";\n      i += \"?ts=\" + new Date().getTime() + Math.random(), n.open(\"get\", i, !0), n.onerror = function (e) {\n        o._abort(\"server-error\", \"Could not get peers from the server.\"), t([]);\n      }, n.onreadystatechange = function () {\n        if (4 === n.readyState) {\n          if (401 === n.status) {\n            var i = \"\";\n            throw i = o.options.host !== e.util.CLOUD_HOST ? \"It looks like you're using the cloud server. You can email team@peerjs.com to enable peer listing for your API key.\" : \"You need to enable `allow_discovery` on your self-hosted PeerServer to use this feature.\", t([]), new Error(\"It doesn't look like you have permission to list peers IDs. \" + i);\n          }\n\n          200 !== n.status ? t([]) : t(JSON.parse(n.responseText));\n        }\n      }, n.send(null);\n    };\n  }, {\n    \"./util\": \"BHXf\",\n    \"eventemitter3\": \"2JJl\",\n    \"./socket\": \"wJlv\",\n    \"./mediaconnection\": \"dbHP\",\n    \"./dataconnection\": \"GBTQ\"\n  }],\n  \"iTK6\": [function (require, module, exports) {\n    \"use strict\";\n\n    var e = this && this.__importDefault || function (e) {\n      return e && e.__esModule ? e : {\n        default: e\n      };\n    };\n\n    exports.__esModule = !0;\n\n    var i = require(\"./util\"),\n        n = require(\"./adapter\"),\n        o = require(\"./socket\"),\n        t = require(\"./mediaconnection\"),\n        r = require(\"./dataconnection\"),\n        a = require(\"./peer\"),\n        d = require(\"./negotiator\"),\n        c = e(require(\"js-binarypack\"));\n\n    window.Socket = o.Socket, window.MediaConnection = t.MediaConnection, window.DataConnection = r.DataConnection, window.Peer = a.Peer, window.RTCPeerConnection = n.RTCPeerConnection, window.RTCSessionDescription = n.RTCSessionDescription, window.RTCIceCandidate = n.RTCIceCandidate, window.Negotiator = d.Negotiator, window.util = i.util, window.BinaryPack = c.default, exports.default = a.Peer;\n  }, {\n    \"./util\": \"BHXf\",\n    \"./adapter\": \"sXtV\",\n    \"./socket\": \"wJlv\",\n    \"./mediaconnection\": \"dbHP\",\n    \"./dataconnection\": \"GBTQ\",\n    \"./peer\": \"Hxpd\",\n    \"./negotiator\": \"HCdX\",\n    \"js-binarypack\": \"lHOc\"\n  }]\n}, {}, [\"iTK6\"], null);","map":null,"metadata":{},"sourceType":"script"}